
| #   | title                              | path                                      | content                                                                                                                                                                                  | check |
| --- | ---------------------------------- | ----------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- |
| 1   | 하나의 API에서 response를 조작해서 넘겨주어도 되는가 | `best.controller.js`                      | Best 페이지는 각 카테고리 + 월/주/일 별 판매량으로 순위를 매겨 정보를 가져오는 페이지<br><br>두 개의 콜렉션(purchase, product) 를 건드리고 1,2,3등 상품은 항상 고정되어야 한다.<br><br>-> 1,2,3 등 상품은 다른 API?<br>-> 상품을 가져오는 API에서 구분하여 응답해도 되는가? |       |
| 2   | google recaptcha                   | re-captcha.vue                            | plugin 화 브리핑 및 validation 확인                                                                                                                                                             |       |
| 3   | login service                      | 1. users.existence<br>2. oauth.controller | 1. 로그인 서비스 브리핑<br><br>2. refreshToken 보안?                                                                                                                                                |       |
| 4   | common file                        |                                           | 1. common file 에 보관하는 이유?<br>2. user file, board file 구분 가능?                                                                                                                             |       |
| 5   | 미니샵 권한                             | aside-button-group<br>main-header         | 1. 로그인하지 않았을 때, 접근 제한 시, 버튼을 눌렀을 때? 또는 마은트 될 때?<br><br>2. 접근 제한 방식 @click / v-if                                                                                                         |       |

#### 1. 하나의 API에서 response를 조작해서 넘겨주어도 되는가

`best` page에서는 1,2,3 등 상품을 고정시킨 뒤, 4등부터는 pagination을 통해 순위의 변동이 일어난다. 즉, `skip` 과 `limit`값에 상관없이, 1,2,3등 상품은 항상 고정되어 있음과 동시에 나머지 상품을 호출해야 한다.

이 과정에서 
1. 1,2,3 등 상품을 호출하는 `bestProducts` API 와, `skip+3` 부터 호출되는 `otherProducts` API 를 구분하여 두 번 호출한다.
2. 모든 상품을 호출하는 `products` API에서 비즈니스 로직을 통해, `response: { bestProducts, otherProducts}` 로 응답한다
로 고민하게 되었다.


	내가 먼저 고민하고 적용시켰던 방식
나는 2번을 선택하게 되었다. 
```javascript
aggregate._bestProducts = (await ShopPurchase.aggregate([...query, {$sort: { count: -1, _id: -1 }}, {$skip: 0}, {$limit: 3}])).map(({ _id })=> _id);

aggregate.totalCount = await ShopPurchase.aggregate([...query, {$count: 'totalCount'}]);

aggregate._products = (await ShopPurchase.aggregate([...query, {$sort: { count: -1, _id: -1 }}, {$skip: skip + 3}, {$limit: limit}])).map(({ _id })=> _id);

```

`bestProducts`와 `otherProdcuts`는 사실 `skip`값을 제외하고는 동일한 query를 통해 데이터를 가져오게 된다. 

```javascript
let query = [{
	$match: {
		"createdAt": aggregate.createdAt,
		...(filter._category && {"product._category": filter._category})
	}
},
{
	$group: {
		_id: "$_product",
		count: { $sum: 1 },
	}
}];
```

`purchases` collection과 `products`colelction을 조회하여 `aggregate`를 통해 query를 생성해주었는데, 동일한 로직에 대하여 중복된 API를 또다시 생성하며 호출하고 싶지 않았다.

	코드리뷰를 통해 얻은 방식

코드의 재사용성과 API 컨벤션에 대해 강조해주셨다. 

두 개의 collection의 `aggregate` 통해 `products` 배열을 가져온다는 측면에서 동일한 API라면 조건을 통해 하나의 API를 두 번 호출하면 `bestProducts`와 `otherProducts`를 구분할 수 있다.

즉, 두 API의 차이는 단지 `skip` 밖에 없는 거라면
```javascript
const { bestProducts } = await api.v1.shops.best.gets({
	headers: { skip: 0 },
	params: this.params
})

const { otherProducts } = await api.v1.shops.best.gets({
	headers: { skip: this.skip + 3 },
	params: this.params
})
```

뭐 이런 방식으로 호출해서 굳이 백에서 response를 나누지 말고 기존에 사용하던 API 템플릿에 맞게 구분된 값들을 가져올 수 있다.

#### 2. Google recaptcha 사용법 브리핑 및 피드백

Verification Flow:
1. client 에서 captcha 를 진행한다.
2. `grecaptcha.getResponse` 를 통해 토큰을 발행한다.
3. 서버로 토큰을 전송하고, 서버에서 구글 서버로 해당 토큰과 `secret` 을 전송하여 인증 여부를 받아온다.
4. 인증 여부에 따라 해당 폼을 비즈니스 로직에 응용한다.

```javascript
// @/components/plugins/recaptcha.vue
<template>
    <div id="g-recaptcha" class="g-recaptcha" :data-sitekey="rcapt_key"></div>
</template>

<script>
export default {
    data:()=>({
        rcapt_key: process.env.VUE_APP_RECAPTCHA_KEY,
        rcapt_id: 0,
    }),
    methods: {
        init(){
            if (window.grecaptcha) {
                this.rcapt_id = grecaptcha.render( $('.g-recaptcha')[0], { sitekey : this.rcapt_key });
            };
        },
        async captcha(){
            try{
                let token = grecaptcha.getResponse(this.rcapt_id);
                this.$emit("input", token);
            } catch(error){
                console.error(error);
                alert(error.response ? error.response.data.message : error.message);
            }
        },
    },
    mounted(){
        this.init();
    }
}
</script>
```

```javascript
// @/plugins/recaptcha.js
import axios from "axios";

const RECAPTCHA_SECRET = process.env.RECAPTCHA_SECRET;  

export function verifyToken(token){
    return new Promise(async (resolve, reject)=> {
        try{
            const response = await axios({
                method: "post",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                url:"https://www.google.com/recaptcha/api/siteverify",
                data: `secret=${RECAPTCHA_SECRET}&response=${token}`,
            });
            //sample response
            // {
            //     success: true,
            //     challenge_ts: '2024-03-11T03:02:14Z',
            //     hostname: 'localhost'
            // }
            resolve(response.data);
        } catch(error){
            reject(error);
        }
    })
}
```


### 3. Login 서비스 구현 브리핑

`../projects/railymall/process.canvas ` join 참고

### 4. Common-Files 
현재 파일과 관련된 모든 `API` 는 `commin-files`라는 collection에 저장되고 있다.
```javascript
const schema = new mongoose.Schema(
    {
        _id: { type: mongoose.Schema.Types.ObjectId, auto: true },
  
        _user: { type: mongoose.Schema.Types.ObjectId },
  
        _brand: { type: mongoose.Schema.Types.ObjectId },
        _product: { type: mongoose.Schema.Types.ObjectId },
  
        /////////////////////////////////////////
        // 파일 기본정보
        /////////////////////////////////////////
        // url:         파일 경로
        // fileName:    파일 이름
        /////////////////////////////////////////
        url: { type: String, default: null },
        fileName: { type: String, default: null },
  
        createdAt: { type: Date, default: Date.now },
        updatedAt: { type: Date, default: Date.now },
    },
    options
);
```

저장되는 파일의 type값에 따라 `_user, _brand, _product`로 구분되어 파일 url과 함께 저장된다.

하지만 파일이 점차 많아질수록 파일 하나를 조회해오는데 걸리는 시간이 점차 증가할 것인데, 이를 type과 함께 하나의 collection에 저장하는 것이 아닌, type에 따라 collection을 새로 생성하는 것은 어떤지?

`_user`와 관련된 파일은 `user-files` / `_board`와 관련된 파일은 `board-files` 이런 식으로 말이다.

=> 기존에 파일들은 10,000개의 데이터 이내에 파일이 저장되어서 하나로 통합해도 되었다. 만약 분리를 시키게 된다면 `discriminator` 통해서 분리 시도해봐라

#### 5.미니샵 권한

로그인되지 않은 회원이 회원 서비스에 접근하게 될 때, 버튼을 누르는 시점에서 막아야 하나?
또는 해당 라우터에 진입하였을 때 막아야 하나?

처음에는 해당 버튼을 눌렀을 때, URL이 변경된 뒤에 "로그인이 필요"하다는 메세지가 호출되었기 때문에, 버튼에 이벤트를 걸어 접근을 제한시켰다.

하지만 만약, 유저가 URL을 직접 치고 들어간다면? 버튼에 걸린 이벤트를 무시하고 회원 서비스에 접근하게 될 것이다.

이에 대해 `vue-router`에서 제공하는 `beforeEach`를 통해 해당 router에 접근하기 전에 미들웨어처럼 연결된 이벤트를 수행한 후에 라우팅이 되는 기능을 사용하였다.