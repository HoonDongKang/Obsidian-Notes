
## BE

| #   | title                        | path                                                   | content                                                                                                               | checked |
| --- | ---------------------------- | ------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- | ------- |
| 1   | 검색 이벤트는 parent? componenent? | ProductListPage -> product-lis-filter -> filter-prices | 두 번 component로 들어가있는 위치에서 query로 검색 이벤트를 발생시킬 때,<br><br>1. $router.push({query})<br>2. emit                           | ✔︎      |
| 2   | 판매량, 좋아요 수 주문 field?         | product.js                                             | 좋아요 누르면 DB에 좋아요 기록만 기록 -> post, delete 시, product likeCount +1, -1?<br><br>판매순 정렬 - 주문 완료 시 product soldCount +1, -1? | ✔︎      |
| 3   | init은 보통 언제?                 | filter-prices                                          | 폼을 사용할 때, init을 사용<br><br>filter 처럼 여러 input field의 경우 init 필요?                                                       | ✔︎      |
| 4   | v-tab active                 | components->client->shop->best-list-tabs               | 1. 부모에서 active 설정을 어떻게 자식으로 보내주나?<br><br>2. active 설정 방법                                                              | ✔︎      |
| 5   | tab-tertiary                 |                                                        | 컴포넌트 재사용                                                                                                              | ✔︎      |


#### 1. 검색 이벤트는 parent? componenent?

하나의 페이지 안에 여러 컴포넌트가 존재하고 컴포넌트 내부적으로도 또다른 자식 컴포넌트가 존재할 수 있다.
그렇다면 자식 컴포넌트 내부에서 클릭으로 인해 라우팅 변경이 일어나야할 경우에는 
1. `emit`을 통해 값을 전달하여 메인 페이지에서 `search`를 일어켜야 하나?
2. 이벤트가 발생하는 해당 컴포넌트 내부에서 `$router.push` 를 통해 라우팅을 변경해주면 되나? 

=> 상황에 따라 사용 조건이 다르다.
1. `$router.push`의 경우에는 메인 페이지에서 `query`통해 통제해야 할 리스트가 한 가지만 있을 경우 사용 가능하다. 
2. `emit` 은 내가 원하는 값을 부모로 올려보낼 수 있기 때문에, type 값처럼 변경이 필요한 리스트를 구분할 수 있는 구분자를 통해 여러 리스트여도 원하는 리스트만 `query`값을 통해 변경시킬 수 있다는 이점이 있다.
 
 ex) 메인페이지에 상품 리스트와 게시글 리스트가 있고 각 리스트를 월별, 주별, 일별 인기 순위로 정렬할 필요가 있다. 
 -> 정렬을 담당하는 필터 컴포넌트에서 `$router.push`로 이동시키면 어떤 리스트에게 이벤트가 적용될 지 명시적으로 보여지지 않는다(가능은 하겠지만 )
-> 이런 경우 각 리스트의 필터에서 `emit`을 통해 `type: "product / board"` 이런 식으로 값을 지정하여 분기처리를 통해 이벤트 발생 가능
#### 2. 판매량, 좋아요 수 주문 field?

상품의 좋아요 수(likeCount)와 판매량(soldCount) 는 상품 스키마에 필드를 생성해서 관리를 해주어야하나? 또는 virtual로 가상 필드를 생성하여 값을 계산하며 가져와야할 것인가? 
또는 상품 collection이 아닌 각 collection에 해당하는 (like, purchase)에서 count하여 가져와줄 수 있나?

```javascript
// Product.js
const schema = new mongoose.Schema({
	_id: { type: mongoose.Schema.Types.ObjectId, auto: true },

	...

	likeCount: { type: Number, default: 0 },
	soldCount: { type: Number, default: 0 }
}) 

// like 증가 시 => like는 상품뿐만 아니라 다른 collection에서도 사용되므로 api 처리
await ShopProduct.updateOne({ _id: req.body._product }, { $inc: { likeCount: 1 }})

// product 구매 시
schema.post("save", function (doc){
	const { ShopProcut } = require("@/models/shop");

	await ShopProduct.updateOne({ _id: doc._id }, { $inc: { likeCount: 1 }})
})
```

```javascript
//virtual
schema.virtual("likeCount").get(fucnction(value, virtual, doc) {
	const { ShopProcut } = require("@/models/shop");

	return await ShopProduct.countDocuments({ _product: doc._id });
})
```

```javascript
//API
await ShopProduct.countDocuments({ _product: doc._id });
```

**virtual** : 새로운 가상 필드를 생성하여 가져오는 것은 개발 소요가 크지 않아 빠르게 개발이 가능하지만 데이터를 계산 후 불러오기 때문에 응답 시간이 증가됨.

**field 생성** : 이벤트가 발생할 때마다 증감되는 필드로, 빠르게 원하는 데이터를 불러올 수 있다. 하지만 해당 컬렉션과의 결합도가 높아지고, 증감을 위해서는 이벤트 발생이 필연적이다( DB 조작 시 )

=> 해당 이벤트를 수행하는 페이지의 트래픽은 어느 정도 될 것으로 예상하는가? 
	페이지를 불러오는 데이터의 양에 따라 판단할 수 있을 것 같다. 해당 페이지에 계산되어 가져오는 데이터의 수가 많다면 필드를 생성하여 응답 시간을 줄이는 것이 옳다. 하지만 페이지네이션으로 적은 양의 데이터만 불러오는 것이라면 가상 필드를 생성하여 데이터를 계산하는 것도 나쁘진 않다. 

#### 3. init은 보통 언제 사용하는가?

보통 form을 작성할 때, 초기화를 위해서 init 틀을 구성하여 새로운 변수를 생성한다. 
init을 생성하는 기준점이 있는가? 
회원가입, 문의 form과 같이 input 필드가 여러개일 경우, 데이터 관리를 위해 init을 생성하지만
상품 필터 기능과 같이 input 필드가 있지만 필수값이 있지 않거나 그 개수가 적다면 생성할 필요가 없는 것인가?

```javascript
export const initBank = (bank = {}) => ({
...bank,
code: bank?.code || null,
accountNumber: bank?.accountNumber || null,
accountHolder: bank?.accountHolder || null,
});
```

=> **init이 필요한 기준점**
1. 객체 내부에 depth가 존재할 경우
	-  객체에 depth로 들어갈 경우, 원본 데이터가 유실되거나 변경될 가능성이 있다. ( Object.assign은 1 depth까지만 새로운 객체를 생성하며 2 depth로 들어가면 참조값으로 복사한다 )
2. 해당 form 의 필드값을 명시적으로 보여줘야 할 때
	- 컴포넌트로 이루어진 form의 경우, input field가 코드 상 흩어져있기 때문에 init을 통해 데이터를 명시적으로 보여줄 필요가 있다.
3. JSDoc
	- 기준점은 아니지만 JSDoc을 통해 생성하면 해당 폼 작성 시, intellisense나 타입 힌트 제공 가능


#### 4. v-tab active

tab을 active 시키기 위해서는 경로를 설정해주어야 한다. 
 - `exact` query까지 동일해야 active
 - `exact-path` path까지만 동일하면 active
 - `active` :class를 통해 active 값을 적용시켜 customizing 가능

```vue
<template>
	<v-tabs grow>
	<tab-primary exact v-for="(item, index) in tabItems" :key="index" :to="item.to" :class="{ active }" @click.prevent="$router.push(item.to)">	
	{{ item.text }}
	</tab-primary>
</v-tabs>
</template>
<script>
computed: {
	...mapState(["categories"]),
	tabItems(){
	let items = [{
		text: "전체보기", to: { path: "/shop/best"}
		, active: !this.$route.query.category
	}];
	const categories = this.categories.map(category => ({
		text: category.name,
 		to: { path: "/shop/best", query: { ...this.$route.query, category:   category.code }},
		active: this.active(category)
}));

	return [...items, ...categories];
},
methods: {
	active(item){
		const isSamePath = this.$route.path == item.to.path;
		const isSameQuery = this.$route.query.category == item.to?.query?.category;
		return isSamePath && isSameQuery;
	}
}

</script>
```

=> `click.prevent` : click 이벤트를 중단시키고 바인딩한 메서드를 동작시킨다.
- 여기서는 to를 통한 이벤트를 중단시키고 `$router.push` 를 실행시킨다.

#### 5. tab-tertiary 재사용성

`tab-tertiary` 라는 컴포넌트는 스타일된 v-tab만을 갖고 있고 로직이 없는 상태.
-> 데이터 바인딩을 통해 서로 다른 `items`를 넘겨 재사용성을 해줄 수 있는 가?

```javascript
v-bind={ "$attrs", ...data } 

$attrs는 전달된 모든 데이터를 바인딩해준다
그 중, 초기화가 필요한 값은 spread 연산자로 빼줄 수 있다.
```