### Goal
상품 목록을 가져오는 과정에서 판매량 순으로 정렬하여 데이터를 가져와야 한다.
### Condition
1. 판매량은 상품 목록을 조회하는 날짜으로부터 한달 전까지의 구매 데이터로 한정한다.
2. 환불과 취소는 고려하지 않고 소비자가 상품을 구매하면 판매량에 합산한다.
3. 구매 데이터는 `ShopPurchase` collection에, 상품 데이터는 `ShopProduct`collection에 저장되며, `_product` 값으로 관계가 설정되어 있다.
### Try
1차시도
```javascript
// 해당 카테고리의 한달전 ~ 금일 구매확정 데이터

let products = (await ShopProduct.find(filter));

let purchases = (await ShopPurchase.find({ 
	"product._category": filter._category, 
	createdAt: { $gte: dayjs().endOf("day").subtract(1, "month").toDate() },
	purchaseStatus: PURCHASE_PURCHASE_STATUSES.PURCHASE_COMPLETE.value }).select("product._id"))
.reduce((acc, cur)=> {
    const existingItem = acc.find(item => item._product.equals(cur.product._id));
    existingItem 
		? existingItem.count++ 
		: acc.push({ _product: cur.product._id, count: 1 });
    return acc;
},[]);

  
let result = products.map((product)=>  {
    const purchase = purchases
		.find(({ _product})=> _product.equals(product._id)) || { count: 0 };
	
    return { ...product, count: purchase.count};
});
  
console.log(result, "result")
```

1. 조회하고자 하는 상품 리스트를 가져온다. (`products`)
2. 한 달 이내에 판매된 판매리스트를 가져온다.(`purchases`)
3. `purchases`를 반복문을 통해 `_products`값이 겹치면 `count ++`을 해준다.
4. `products` 반복문을 통해 `purchases`와 비교하여 `_products` 값으로 `count` 데이터를 바인딩해준다.

=> 모든 상품과 판매량을 반복문을 통해 조회 

2차 시도
```javascript
// aggregate 
aggregate = [
  { // [results, totalCount] 로 반환
    $facet:{
      results: [
          {// 해당 collection 참조
            $lookup: {
              from: "shop-purchases",
              // $lookup하기 전 pipleline 구축
              pipeline:[{
	              $match: {$expr: {
						$and: [
			{$in: [ "$product._category", mapping(category)]},
			{$gte: [ "$createdAt", dayjs().endOf('day').subtract(1, 'month').toDate()]},
						]
			}}
			}],
              localField: "_id",
              foreignField: "_product",
              as: "purchase"
            }
          },
          {//populate 할 수가 없어서 lookup으로 가져온다
              $lookup: {
			  from:"users",
			  localField: "_seller",
			  foreignField: "_id",
			  as:"seller"
			              }
			          },
          {//populate 할 수가 없어서 lookup으로 가져온다22
              $lookup: {
			  from:"common-files",
			  localField: "_thumb",
			  foreignField: "_id",
			  as:"thumb"
			              }
          },
          { //purchase 배열의 요소 길이 = 즉 판매량
            $addFields:{
				purchaseCount: { $size: "$purchase"}
            }
          },
          { $sort: { purchaseCount: -1 }}, { $skip: skip }, { $limit: limit }
      ],
      totalCount: [{$count: 'totalCount'}]
    }
  }
]


let [{ results, totalCount}] = await ShopProduct.aggregate([{ $match: filter}, ...aggregate]);

products = makeVirtuals(results);

// product를 find해서 오면 schema.virutal.get으로 
// discountPrice, discountRate, salePrice 를 가상 필드로 계산해서 가져오는데,
// aggregate는 거쳐오질 않아서 직접 property 계산 후 생성

const makeVirtuals= (products)=> {
    // aggregate로 virtual 필드를 수동으로 만드는 함수
    return products.map((product)=> {
        let { discount, discountEnabled } = product;
        product.discountPrice = 0;
        product.discountRate = 0;
        if(discount && discountEnabled){
            if (!discount.expiration.enabled || (discount.expiration.enabled && 
	            dayjs().isAfter(discount.expiration.startDate) && 
	            dayjs().isBefore(discount.expiration.endDate))) {
            switch (discount.unit) {
               case "percent":
			product.discountPrice = Math.floor((product.price * discount.amount) / 100);
			product.discountRate = discount.amount;
			break;
               case "won":
			product.discountPrice = discount.amount;
			product.discountRate = Math.ceil((discount.amount / product.price) * 100);
            }
        }
    }
    product.salePrice = product.price - product.discountPrice;
    return product;
    })
}```

```
$facet : 조회하고자 하는 데이터의 구조(shape)을 형성할 수 있다.
$lookup : 다른 콜렉션 조회
{
	from : 조회하고자하는 콜렉션
	localField : 해당 콜렉션의 관계 필드
	foreignField : 조회 콜렉션의 관계 필드
	as : alias
	let : 변수
	pipeline : 조회하고자 하는 콜렉션에 pipeline을 통해 조작 (필터를 통해 조회)
}
$addFields: 조회되는 데이터에 필드 추가 (모든 필드 +a)
$projects: 조회하는 필드 추가, 제거 (필드 하나씩 지정)
```

두 가지정도 봐야할 점이 있다.
1. `totalCount` 
기존에 사용하던 controller의 경우, `totalCount`를 따로 쿼리를 통해 구해왔지만 `aggregate`를 통해 가져오는 값은 `skip` 과 `limit`을 직접 걸어줘서 가져와야 하기 때문에, `$facet`을 통해 해당 쿼리와 함께 총 판매량을 가져왔다.
2. `virtual, populate` 
 `ShopProduct`에서 상품을 조회할 때, 스키마에서 설정한 `virtual` 과 `populate`은 `aggregate`를 통해 가져올 수 없다. 그렇기 때문에, 해당 조회가 사용되는 페이지에서 필요한 `virtual` 과 `populate`은 직접 추가해주어야 했다.

3차시도
```javascript
let aggregate = [{
    $facet: {
        _products: [
            {
$lookup: {
  from: "shop-purchases",
  pipeline:[{
  $match: {
    $expr: {
      $and: [
          {$in: [ "$product._category", mapping(category)]},
          {$gte: [ "$createdAt", dayjs().endOf('day').subtract(1, 'month').toDate()]},
      ]
    }
  }
}],
  localField: "_id",
  foreignField: "_product",
  as: "purchase"
}
              },
              { $project: { _id: 1, purchaseCount: { $size: "$purchase" } }},
              { $sort: { purchaseCount: -1 }}, { $skip: skip }, { $limit: limit }
        ],
        totalCount: [{$count: 'totalCount'}]
    }}
  ]

let [{_products, totalCount}] = await ShopProduct.aggregate([{ $match: filter}, ...aggregate]);
filter._id = { $in: _products.map(({ _id }) => _id) };
aggregateSummary = totalCount[0];
skip= 0;
limit= 0;

//find
var summary = {
    totalCount: await ShopProduct.countDocuments(filter),
};
  
var products = await ShopProduct.find(filter).sort(sort).skip(skip).limit(limit).populate(populate).populate(["bundleds", "meta.reviews", "seller"]);

switch(querySort){
    // 판매순의 경우 _products(filter._id.$in) 순서대로 정렬
    case PRODUCT_SORT.SALE_DESC.value:
        products = filter._id.$in.map((id)=> products.find((product)=> product._id.equals(id)));
        summary = aggregateSummary;
        break;
}
```

2차시도에서 직접 `virtual` 과 `populate` 을 설정해서 데이터를 변형하는 것은 코드가 너무 복잡하고 난해하다고 생각하여 `aggregate`를 통해 `_product` 값만 조회하여 이를 다시 `ShopProduct`로 `find` 해오기로 결정하였다.

1. `aggregate`를 통해 판매량 순 `_product` 배열 조회
2. `_product`로 `ShopProduct.find()`
3. `find`는 배열 순서를 보장하지 않기 때문에, `_product` 배열대로 순서 정렬