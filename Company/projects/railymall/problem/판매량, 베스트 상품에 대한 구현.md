1차시도
```javascript
// 해당 카테고리의 한달전 ~ 금일 구매확정 데이터

let products = (await ShopProduct.find(filter));

let purchases = (await ShopPurchase.find({ 
	"product._category": filter._category, 
	createdAt: { $gte: dayjs().endOf("day").subtract(1, "month").toDate() },
	purchaseStatus: PURCHASE_PURCHASE_STATUSES.PURCHASE_COMPLETE.value }).select("product._id"))
.reduce((acc, cur)=> {
    const existingItem = acc.find(item => item._product.equals(cur.product._id));
    existingItem 
		? existingItem.count++ 
		: acc.push({ _product: cur.product._id, count: 1 });
    return acc;
},[]);

  
let result = products.map((product)=>  {
    const purchase = purchases
		.find(({ _product})=> _product.equals(product._id)) || { count: 0 };
	
    return { ...product, count: purchase.count};
});
  
console.log(result, "result")
```

2차 시도
```javascript
// aggregate 
aggregate = [
  { // [results, totalCount] 로 반환
    $facet:{
      results: [
          {// 해당 collection 참조
            $lookup: {
              from: "shop-purchases",
              // $lookup하기 전 pipleline 구축
              pipeline:[{
  $match: {
$expr: {
						$and: [
						    {$in: [ "$product._category", mapping(category)]},
						
						    {$gte: [ "$createdAt", dayjs().endOf('day').subtract(1, 'month').toDate()]},
						]
}
  }
}],
              localField: "_id",
              foreignField: "_product",
              as: "purchase"
            }
          },
          {//populate 할 수가 없어서 lookup으로 가져온다
              $lookup: {
  from:"users",
  localField: "_seller",
  foreignField: "_id",
  as:"seller"
              }
          },
          {//populate 할 수가 없어서 lookup으로 가져온다22
              $lookup: {
  from:"common-files",
  localField: "_thumb",
  foreignField: "_id",
  as:"thumb"
              }
          },
          { //purchase 배열의 요소 길이 = 즉 판매량
            $addFields:{
purchaseCount: { $size: "$purchase"}
            }
          },
          { $sort: { purchaseCount: -1 }}, { $skip: skip }, { $limit: limit }
      ],
      totalCount: [{$count: 'totalCount'}]
    }
  }
]


let [{ results, totalCount}] = await ShopProduct.aggregate([{ $match: filter}, ...aggregate]);

products = makeVirtuals(results);

// product를 find해서 오면 schema.virutal.get으로 
// discountPrice, discountRate, salePrice 를 가상 필드로 계산해서 가져오는데,
// aggregate는 거쳐오질 않아서 직접 property 계산 후 생성

const makeVirtuals= (products)=> {
    // aggregate로 virtual 필드를 수동으로 만드는 함수
    return products.map((product)=> {
        let { discount, discountEnabled } = product;
        product.discountPrice = 0;
        product.discountRate = 0;
        if(discount && discountEnabled){
            if (!discount.expiration.enabled || (discount.expiration.enabled && 
	            dayjs().isAfter(discount.expiration.startDate) && 
	            dayjs().isBefore(discount.expiration.endDate))) {
            switch (discount.unit) {
               case "percent":
			product.discountPrice = Math.floor((product.price * discount.amount) / 100);
			product.discountRate = discount.amount;
			break;
               case "won":
			product.discountPrice = discount.amount;
			product.discountRate = Math.ceil((discount.amount / product.price) * 100);
            }
        }
    }
    product.salePrice = product.price - product.discountPrice;
    return product;
    })
}```

3차시도
```javascript
let aggregate = [
    {
        $lookup: {
          from: "shop-purchases",
          pipeline:[{
              $match: {
$expr: {
  $and: [
  {$in: [ "$product._category", mapping(category)]},
  {$gte: [ "$createdAt", dayjs().endOf('day').subtract(1, 'month').toDate()]},
  ]
}
              }
            }],
          localField: "_id",
          foreignField: "_product",
          as: "purchase"
        }
      },
      { $project: { _id: 1, purchaseCount: { $size: "$purchase" } }},
      { $sort: { purchaseCount: -1 }}, { $skip: skip }, { $limit: limit }
  ]
  
let _products = await ShopProduct.aggregate([{ $match: filter}, ...aggregate]);
filter._id = { $in: _products.map(({ _id }) => _id) };

// find
var summary = {
    totalCount: await ShopProduct.countDocuments(filter),
};

var products = await ShopProduct
	.find(filter)
	.sort(sort)
	.skip(skip)
	.limit(limit)
	.populate(populate).populate(["bundleds", "meta.reviews", "seller"]);

switch(querySort){
    // 판매순의 경우 _products(filter._id.$in) 순서대로 정렬
    case PRODUCT_SORT.SALE_DESC.value:
        products = filter._id.$in.map((id)=> 
        products.find((product)=> product._id.equals(id)));
        break;
}
```